
-- 在lua语言中 有两种方式来表示矩阵
-- 第一种方式是使用一个不规则数组(jagged array)
-- 数组的数组 也就是所有元素均是另一个表的表
-- 例如 可以使用如下的代码创建一个全0元素的NxM维矩阵
local mt={}
for i=1,N do
	local row={}
	mt[i]=row
	for j=1,M do
		row[j]=0
	end
end
-- 由于表在lua语言中是一种对象，因此在创建矩阵时必须显式地创建每一行。
-- 一方面，这在C语言中声明一个多维数组更加具体；另一方面，这也给我们提供了更多的灵活性。
-- 例如，只需要将前例中的内层循环改为 for j=1,i do ... end 就可以创建一个三角形矩阵。
-- 使用这套代码三角形矩阵较原来的矩阵可以节约一半的内存。
-- 在Lua中表示矩阵的第二种方式是将两个索引合并为一个。典型情况下，我们通过将第一个索引乘以
-- 一个合适的常量再加上第二个索引来实现这种效果。在这种方式下，我们可以使用一下的代码来
-- 创建一个全0元素的NxM维矩阵
local mt={}
for i=1,N do
	local aux=(i-1)*N
	for j=1，M do
		mt[aux+j]=0
	end
end
-- 应用程序中经常会用到稀疏矩阵(sparse matrix)
-- 这种矩阵大多数元素是0或nil
-- 例如，我们可以使用邻接矩阵(adjacency matrix)来表示
-- 当矩阵(m,n)处元素的值为x时，表示图中的节点m和n是相连的
-- 连接的权重为x
-- 弱上述的两个节点不相连，那么矩阵的(m,n)处元素的值为nil。
--如果要表示一个具有1万个节点的图(其中每个节点有5个邻居)，
--那么需要一个能包含1亿个元素的矩阵(10000列x10000行的方阵)，但是其中大约只有5万个元素不为nil
--每行有5列不为nil,对应每个节点有5个邻居
--许多有关数据结构的数据都会深入讨论如何实现这种稀疏矩阵而不必浪费800MB的内存空间，但在lua
--语言中却很少需要用到那些技巧。这是因为，我们使用表实现数组而表本来就是稀疏的。在第一种实现中(表的表)
--需要1万个表，每个表包含5个元素，总共5万个元素
--在第二种实现中，只需要一个表，其中包含5万个元素。无论哪种实现，都只有非nil的元素才占有空间

-- 由于再有效元素之间存在空洞(nil值),因此不能对稀疏矩阵使用长度运算符。这没什么大不了的，
-- 即使我们能够使用长度运算符，最好也不要那么做。对于大多数针对稀疏矩阵的操作来说，遍历空元素是非常低效的。
-- 相反，可以使用pairs来只遍历非nil的元素。例如，考虑如何进行由不规则数组表示的系数矩阵的矩阵乘法。
-- 假设矩阵a[M,K]乘以矩阵b[K,N]的结果为矩阵c[M,N],常见的矩阵相乘算法形如、
for i=1,M do
	for j=1,N do
		c[i][j]=0
		for k=1,K do
			c[i][j]=c[i][j]+a[i][k]*b[k][j]
		end
	end
end
-- 外层的两个循环遍历了整个结果矩阵，然后内层循环计算每一个元素的值。
-- 对于使用不规则矩阵实现的稀疏矩阵，内层循环会有问题。由于内层循环遍历的是一列b而不是一行
--因此不能在此处使用pairs 这个循环必须遍历每一行来检查对应的行是否在对应列中的有元素。
--除了遍历了少量非0元素以外，这个循环还遍历了所有的0元素。
--由于不知道元素的空间位置，所以在其他场景下遍历一列也可能会有问题
--以下的算法与之前的示例非常类似，但是该算法调换了两个内层循环的顺序。通过这个简单的调整，该算法避免了遍历列
-- 假设'c'的元素都是0
for i=1,M do
	for k=1,K do
		for j=1,N do
			c[i][j]=c[i][j]+a[i][k]*b[k][j]
		end
	end
end
-- 以下展示了上述算法的完整实现，其中使用了pairs来处理稀疏的元素。这种实现只访问非nil元素
-- 同时结果也是稀疏矩阵。此外，下面的代码还删去了结果中偶然为0的元素。
function mult(a,b)
	local c={} -- 结果矩阵
	for i=1,#a do
		local resultline={}
		for k,va in pairs(a[i]) do
			for j,vb in pairs(b[k]) do
				local res=(resultline[j] or 0)+va*vb
				resultline[j]=(res~=0) and res or nil
			end
		end
	end
	return c
end
