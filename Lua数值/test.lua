--4
--0.4
--4.57e-3
--0.3e12
--5E+20
--具有十进制小数或者指数的数值会被当作浮点型值 否则会被当作整型值
--整型值和浮点型值的类型都是 number
--type(3)
--type(3.5)
--type(3.0)
--由于整型值和浮点型值的类型都是"number"所以它们是可以相互转换的
--同时具有相同算数值的整型值和浮点型值在lua语言中是相等的
--1==1.0
---3==-3.0
--0.2e3==200
--在少数情况下，当需要区分整型值和浮点型值时，可以使用函数math.type
--require 'math'
--math.type(3)
--math.type(3.0)

--lua语言像其他语言一样也支持以0x开头的十六进制常量。与其他很多编程语言不同
--lua语言还支持十六进制的浮点数，这种十六进制浮点数由小数部分和以p或P开头的指数部分组成
--0xff
--0x1A3
--0x0.2
--0x1p-1
--0xa.bp2
--可以使用%a参数,通过函数string.format对这种格式进行格式化输出
--string.format("%a",0.1)
--虽然这种格式很难阅读，但是这种格式可以保留所有浮点数的精度，并且比十进制的转换速度更快

--除了加减乘除取负数 单目减法即把减号当作一元运算符使用等常见的算数运算外 Lua语言还支持取
--取整除法floor除法取模和指数运算
--开发人员要么选择忽略整型和浮点型二者之间的不同 要么就完整地控制每一个数值地表示
--因此 所有算术操作符不论操作整型值还是浮点型值 结果都应该是一样的
--如果两个操作数都是整型值，那么结果也是整型值，否则就是浮点型值，当操作数一个是
--整型值一个是浮点型值 lua语言会在进行算术运算前先将整型值转换为浮点型值
--由于两个证书相除的结果并不一定是整数 数学领域称为不能整除 因此除法不遵循上述原则
--为了避免两个整型值相除导致不一样的结果 除法运算操作的永远是浮点数且产生浮点型值的结果
--lua针对整数除法引入了一个称为floor除法的新算术运算符 顾名思义floor除法会对得到的商向
--负无穷取整 从而保证结果是一个整数 这样floor除法就可以与其他算术运算一样遵循同样的规则
--如果 操作数都是整型值 那么结果就是整型值 否则就是浮点型值
--3//2=1
--3.0//2=1.0
--6//2=3
--6.0//2.0=3.0
---9//2=-5
--1.5//0.5=3.0
--以下公式是取模运算的定义
--a%b==a-((a//b)*b)
--如果操作数是整数 那么取模运算的结果也是整数 因此 取模运算也遵循与算术运算相同的规律
--即如果两个操作数均是整型值 则结果为整型 否则为浮点型

--对于整数操作数而言，取模运算的含义没什么特别的，其结果的符号永远与第二个操作数的符号保持一致
--特别地，对于任意指定的正常量K 即使x是负数 表达式x%K的记过也永远在[0,K-1]之间
--例如对于任意整数型值i，表达式i%2的结果均是0或1
--对于实数类型的操作数而言，取模运算有一些不同，例如 x-x%0.01恰好是x保留两位小数
--的结果 x-x%0.001恰好是x保留三位小数的结果
--x=math.pi
--x-x%0.01-->3.14
--x-x%0.001-->3.141
--再比如，我们可以使用取模运算检查某辆车在拐过了指定的角度后是否能够原路返回
--假设使用度作为角度的单位,那么我们可以使用如下的公式
local tolerance=10
function isturnback(angle)
 angle=angle%360
 return (math.abs(angle-180)<tolerance)
end
--而函数对负的角度而言也同样适用
print(isturnback(-180))
--假设使用弧度作为角度的单位，那么我们只需要简单地修改常量的定义即可
local tolerance =0.17
function isturnback(angle)
 angle=angle%(2*math.pi)
 return (math.abs(angle-math.pi)<tolerance)
end
--表达式angle%(2*math.pi)实现了将任意范围的角度归一化到[0,2pi)之间
--lua语言同样支持幂运算，使用符号^表示。像除法一样，幂运算的操作数也永远是浮点类型
--(整型值在幂运算时不能整除，例如，2^-2)我们可以使用x^0.5 来计算x的平方根 x^(1/3)
--来计算x的立方根
