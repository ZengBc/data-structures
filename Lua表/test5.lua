--表标准库
--表标准库提供了操作列表和序列的一些常用函数
--函数table.insert向序列的指定位置插入一个元素，其他元素依次后移
--另一种特殊但常见的情况是调用insert时不指定位置，此时该函数会在序列的最后插入指定的元素
--而不会移动任何元素
t={}
for line in io.lines() do
 table.insert(t,line)
end
print(#t)
--函数table.remove删除并返回序列指定位置的元素 然后将其后的元素向前移动填充删除元素后造成的空洞
--如果在调用该函数时不指定位置 该函数会删除序列的最后一个元素
--借助这两个函数 可以很容易地实现stack 队列 queue 和双端队列double queue
--以栈的实现为例 我们可以使用t={}来表示栈 push 操作可以使用table.insert(t,x)
--pop操作可以调用table.remove(t)实现 调用table.insert(t,1,x)可以实现在栈的顶部进行插入，
--由于后两个函数涉及表中其他元素的移动，所以其运行效率并不是特别高
--当然由于table标准库中的这些函数时使用C语言实现的 所以移动元素所设计循环的性能开销也并不是太昂贵
--因而，对于几百个元素组成的小数组来说这种实现已经足矣
--table.move(a,f,e,t)调用该函数可以将表a中从索引f到e的元素(包含索引f和索引e对应的元素本身)移动到位置t上
--例如 如下代码可以在列表a的开头插入一个元素
table.move(a,1,#a,2)
a[1]=newElement
--如下的代码可以删除第一个元素
table.move(a,2,#a,1)
a[#a]=nil
--应该注意，在计算机领域，移动(move)实际上是将一个值从一个地方拷贝到(copy)到另一个地方
--因此，像上面的例子一样，我们必须在移动后显式地把最后一个元素删除
--函数table.move还支持使用一个表作为可选的参数 当代有可选的表作为参数时
--该函数第一个表中的元素移动到第二个表中 例如 table.move(a,1,#a,1,{})返回列表a地一个克隆(clone)
--通过将表a中地所有元素拷贝到新列表中)table.move(a,1,#a,#b+1,b)将列表a中的所有元素复制到列表b地末尾
