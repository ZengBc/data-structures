-- 使用协程实现多线程
-- 学习如何利用协程实现多线程
-- 正如我们此前所看到的，协程能够实现一种协作式多线程 collaborative multithreading
-- 每个协程都等价于一个线程 一堆yield-resume可以将执行权在不同线程之间切换。不过，
-- 与普通的多线程不同，协程是非抢占的。当一个协程正在运行时，是无法从外部停止它的
--只有当协程显式地要求时候 通过调用函数yield它才会挂起执行 对于有些应用而言
-- 这并没有问题，而对于另外一些应用则不行，当不存在抢占时 变成简单得多 由于在程序中所有的线程间同步都是显式地
--所以我们无需为线程同步问题抓狂，只需要确保一个协程只有在他的临界区critical region
-- 之外调用yield即可
-- 不过对于非抢占式多线程来说，只要有一个线程调用了组赛操作，阻塞整个程序在该操作前都会阻塞
--对于很多应用程序来说，这种行为是无法接受的，而这也正是导致许多程序员不把协程看作传统多线程的一种实现的原因
--接下来 我们会用一个有趣且显而易见的方法来解决这个问题
-- 让我们假设一个典型的多线程场景：我们希望通过HTTP下载多个远程文件。为了下载多个远程文件
--我们必须先知道如何下载一个远程文件，在本例中，我们将使用LuaSocket标准库，要下载一个文件
--必须先打卡一个到对应站点的连接，然后发送下载文件的请求，接收文件（按块）
--最后关闭连接，在lua语言中，可以按以下步骤来完成这项任务。首先加载LuaSocket库
local socket=require "socket"
--然后 定义主机和要下载的文件。
host="www.lua.org"
file="/manual/5.3/manual.html"
--接下来，打开一个TCP连接，连接到该站点的80端口（http协议的默认端口）
--c=assert(socket.connect(host,80))
--这步操作返回一个连接对象，可以用它来发送下载文件的请求
local request=string.format(
	"GET %s HTTP/1.0\r\nhost: %s\r\n\r\n",file,host)
c:send(request)
--接下来 以1kb为一块读取文件，并将
